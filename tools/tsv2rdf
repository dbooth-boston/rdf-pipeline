#! /usr/bin/env perl

# Copyright 2014 by David Booth
# This software is available as free and open source under
# the Apache 2.0 software license, which may be viewed at
# http://www.apache.org/licenses/LICENSE-2.0.html
# Code home: https://github.com/dbooth-boston/rdf-pipeline/

# Convert TSV to RDF.  Whitespace is trimmed from cells.
# Empty cells are skipped -- they do not generate triples.
# Reads stdin, writes stdout.
#
# Regression test for this code is @@ TODO @@ .

# TODO: Include headers in metadata table.
#
# TODO: Add a --guess option to guess column data types
# and primary key.  If multiple columns are candidate keys
# (i.e., have unique values) then weights might be used
# to choose, based on:
#	- earlier column in the table;
#	- column datatype;
#	- column with only positive integers, versus other content;
#	- column name ends with "ID"; 
#	- column values are the same or similar length.
# However, it is easy enough to specify which column is the
# primary key, so we probably should not get overly sophisticated
# in guessing the primary key.   Maybe the primary key column
# could be specified as a pattern (or substring or initial substring) 
# to accommodate minor changes in column names.  For example, 
# a '--primaryKey=foo' option might select the first column whose 
# name contains "foo", and '--primaryKey=^foo$' would have to
# match the whole column name.

##################################################################

use warnings;
use strict;
use Carp;
use URI::Template;

################# Usage ###################
sub Usage
{
return "Usage: $0 [ options ] [ file.ttl ... ]
Options:
  -b, --base=baseUri
	Use baseUri as the base in generating URIs.

  -m, --meta=metadataFile.tsv
	Use metadata from metadataFile.tsv instead of input file.

  -d, --debug
	Print this usage message.

  -h, --help
	Print this usage message.
";
}

##################################################################
################# Main ###################
##################################################################

########### Globals
our $MTABLE;	# Ref to the entire metadata table.  Each row contains:
		#   ($DIRECTIVE, $ARGS, @METAS)
our $TABLE;	# Ref to the entire data table
our @HEADERS;	# Column headers (excluding any #META column header)
our @ORIGINAL_HEADERS;	# Column headers before mods except &Trimming
our $HEADER;	# Current header: $HEADER[$COLUMN]
our %NAMESPACE;	# Prefix->namespace mappings
our $MROW;	# Index of current meta row
our $ROW;	# Index of current data row
our $COLUMN;	# Index of current meta/data/header column
our $DIRECTIVE;	# Directive parsed from #META column of current $MROW
our $ARGS;	# Args parsed from #META column of current $MROW
our @METAS;	# Meta cell values for current $MROW
our $META;	# Meta cell value for current $MROW and $COLUMN
our $S;		# Turtle subject of current data $ROW
our $P;		# Turtle predicate of current data $ROW and $COLUMN
our %DATA;	# Maps column name to cell value in current row
our %CLASS;	# Maps column name to class URI Template
our %PREDICATE;	# maps column name to predicate URI Template
########### Other globals, probably not used by users
our $NROWS;	# Number of data rows (excludes header row)
our $NCOLUMNS;	# Number of data columns (and meta columns)
########### To be made obsolete probably:
our %HEADER_TO_COLUMN;	# Maps header to column index
our %KEY_TO_ROW;	# Maps header to column hash to row number (0 based)
our %PK_TO_ROW;		# Maps $PRIMARY_KEY column hash to row number (0 based)
our $PRIMARY_KEY;	# Header name of primary key column

my $baseUri = "http://example/";
my $help = 0;
my $debug = 0;
my $metadataFile = "";
use Getopt::Long; # Perl
GetOptions(
                "debug|d" => \$debug,
                "help|h" => \$help,
                "base|b=s" => \$baseUri,
                "meta|m=s" => \$metadataFile,
                ) or die "$0: Error reading options.  " . &Usage();

die &Usage() if $help;
$baseUri || die &Usage();

# print "\@prefix : <$baseUri>\n\n";

$TABLE = &ReadTsv();
# warn "======================= DATA table: ======================\n" if $debug;
# &PrintTable($TABLE) if $debug;
# warn "==========================================================\n" if $debug;
# warn "\n" if $debug;

$MTABLE = &RemoveMetadataRows($TABLE);
my $headersRef = shift @{$TABLE};
@HEADERS = map {&Trim($_)} @{$headersRef};
@ORIGINAL_HEADERS = @HEADERS;

if ($metadataFile) {
	warn "Reading separate metadataFile: $metadataFile\n" if $debug;
	my $rawMeta = &ReadTsv($metadataFile);
	$MTABLE = &RemoveMetadataRows($rawMeta);
	# Make sure the metadata headers match the data headers.
	my $metaHeadersRef = ${$rawMeta}[0];
	$metaHeadersRef || die "$0: [ERROR] metadataFile has no header row: $metadataFile\n";
	my @metaHeaders = @{$metaHeadersRef};
	my $nmh = scalar(@metaHeaders);
	my $nh = scalar(@HEADERS);
	for (my $i=0; $i<@metaHeaders && $i<@HEADERS; $i++) {
		$metaHeaders[$i] eq $HEADERS[$i] || die "$0: [ERROR] Metadata header ($metaHeaders[$i]) in column $i does not match data header ($HEADERS[$i]) in corresponding data column.\n";
		}	
	if ($nmh > $nh) {
		my $nExtras = $nmh - $nh;
		my $extras = join("|", @metaHeaders[ $#HEADERS+1 .. $#metaHeaders ] );
		die "$0: [ERROR] $nExtras extra metadata columns: $extras\n";
		}
	elsif ($nmh < $nh) {
		my $nExtras = $nh - $nmh;
		my $extras = join("|", @HEADERS[ $#metaHeaders+1 .. $#HEADERS ] );
		die "$0: [ERROR] $nExtras extra data columns: $extras\n";
		}
	}

# print "======================= META table: ======================\n" if $debug;
# &PrintTable($MTABLE) if $debug;
# print "==========================================================\n" if $debug;
# warn "\n" if $debug;
# print "======================= DATA table: ======================\n" if $debug;
# &PrintTable($TABLE) if $debug;
# print "==========================================================\n" if $debug;
# print "\n" if $debug;
# exit 0;

{
no warnings qw(qw);
%NAMESPACE = qw(
	rdf:	<http://www.w3.org/1999/02/22-rdf-syntax-ns#>
	dc:	<http://purl.org/dc/elements/1.1/>
	rdfs:	<http://www.w3.org/2000/01/rdf-schema#>
	owl:	<http://www.w3.org/2002/07/owl#>
	xsd:	<http://www.w3.org/2001/XMLSchema#>
	);
}

my %uriTemplateValues;	# For #SetUriTemplateVariable

my %isPreProcessingDirective = map {($_,1)} qw( 
	Prefix 
	SetUriTemplateVariable
	Class
	Property
	Object
	Perl_PreRun
	);

$NROWS = scalar(@$TABLE);
$NCOLUMNS = scalar(@HEADERS);

# Pre-processing directives 
for ($MROW=0; $MROW<@{$MTABLE}; $MROW++) {
	# ($DIRECTIVE, $ARGS, @METAS) = @{$mr};
	&SetGlobalsForMetaRow();
	next if !$isPreProcessingDirective{$DIRECTIVE};
	warn "BEGIN Preprocessing DIRECTIVE: $DIRECTIVE ARGS: $ARGS MROW: $MROW METAS: @METAS\n" if $debug > 0;
	no strict 'refs';
	&{$DIRECTIVE}();	# All args are passed as globals
	warn "END Preprocessing DIRECTIVE: $DIRECTIVE ARGS: $ARGS MROW: $MROW METAS: @METAS\n" if $debug > 1;
	&ResetGlobalsForMetaRow();
	}

# Output namespaces.
foreach my $prefix (sort keys %NAMESPACE) {
	print "\@prefix $prefix\t$NAMESPACE{$prefix} .\n";
	}
print "\n";

# Set up maps/indexes.
warn "NCOLUMNS: $NCOLUMNS NROWS: $NROWS headers: @HEADERS\n" if $debug;
for ($COLUMN=0; $COLUMN<$NCOLUMNS; $COLUMN++) {
	$HEADER_TO_COLUMN{$HEADERS[$COLUMN]} = $COLUMN;
	}
for ($ROW=0; $ROW<$NROWS; $ROW++) {
	for ($COLUMN=0; $COLUMN<$NCOLUMNS; $COLUMN++) {
		# For PK 'PROJECT ID' value 'P001' in first row:
		# $KEY_TO_ROW{'PROJECT ID'}->{'P001'} = 0;
		$KEY_TO_ROW{$HEADERS[$COLUMN]}->{$TABLE->[$ROW][$COLUMN]} = $ROW;
		$PK_TO_ROW{$TABLE->[$ROW][$COLUMN]} = $ROW
			if defined($PRIMARY_KEY) && $HEADERS[$COLUMN] eq $PRIMARY_KEY;
		}
	}

# Process all data rows.
for ($ROW=0; $ROW<$NROWS; $ROW++) {
	warn "================= DATA ROW ====================\n" if $debug;
	warn " ROW $ROW: @{$TABLE->[$ROW]}\n" if $debug;
	warn "===============================================\n" if $debug;
	$S = "_:row$ROW";
	my @underscores = map {""} @HEADERS;
	my @predicates = map {""} @HEADERS;
	my $firstMeta = 1;
	# for ($COLUMN=0; $COLUMN<$NCOLUMNS; $COLUMN++) {
	foreach my $mr (@{$MTABLE}) {
		my ($directive, $args, @metaFields) = @{$mr};
		$directive || confess "Died";
		# Preprocessing directives have already been handled, so skip:
		next if $isPreProcessingDirective{$directive};
		@metaFields || confess "Died";
		@HEADERS == @metaFields || confess "Died";
		$ARGS = $args;
		my @r = @{$TABLE->[$ROW]};	# TODO: comment out
		warn "ROW CONTAINS: @r\n" if $debug > 1;
		warn "--------------- META --------------------\n" if $debug;
		warn "Directive: $directive ARGS: $ARGS metaFields: @metaFields\n" if $debug;
		warn "UNDERSCORE: $_\n" if $debug > 1;
		for ($COLUMN=0; $COLUMN<$NCOLUMNS; $COLUMN++) {
			$HEADER = $HEADERS[$COLUMN];
			$META = $metaFields[$COLUMN];
			if ($firstMeta) {
				# Init per-column data
				my $p = &MakeVar($HEADER) || "UNDEFINED";
				$predicates[$COLUMN] = "table:$p";
				$underscores[$COLUMN] = $TABLE->[$ROW]->[$COLUMN];
				}
			no strict 'refs';
			defined(&{$directive}) || die "$0: [ERROR] No function $directive defined for directive: #$directive\n";
			# TODO: make this not depend on having the metadata
			# columns in the same order as the data columns:
			$_ = $underscores[$COLUMN];
			$P = $predicates[$COLUMN];
			%DATA = map {($HEADERS[$_], $underscores[$_])} 0..$#HEADERS;
			warn "Calling &$directive();\n" if $debug > 1;
			&{$directive}();
			warn "Done calling &$directive();\n" if $debug > 1;
			$underscores[$COLUMN] = $_;
			$predicates[$COLUMN] = $P;
			}
		$firstMeta = 0;
		}
	}
exit 0;


#####################################################################
######################### END OF MAIN ###############################
#####################################################################

################## SetGlobalsForMetaColumn #################
# Set globals: $META and $HEADER.
# from $METAS[$COLUMN] and $HEADERS[$COLUMN].
# They are relative to $COLUMN, which 
# must already be set.  @METAS must already be set also,
# as by calling SetGlobalsForMetaRow.
sub SetGlobalsForMetaColumn
{
defined($COLUMN) || confess "Died";
@METAS || confess "Died";
@HEADERS || confess "Died";
$META = $METAS[$COLUMN];
$HEADER = $HEADERS[$COLUMN];
defined($META) || confess "Died";
defined($HEADER) || confess "Died";
}

################## ResetGlobalsForMetaColumn #################
# Reset globals: $METAS[$COLUMN], $HEADERS[$COLUMN]
# from $META and $HEADER.
# They are relative to $COLUMN, which 
# must already be set.  $META (and @METAS) must already be set also,
# as by calling SetGlobalsForMetaColumn.
sub ResetGlobalsForMetaColumn
{
defined($COLUMN) || confess "Died";
@METAS || confess "Died";
@HEADERS || confess "Died";
defined($META) || confess "Died";
defined($HEADER) || confess "Died";
$METAS[$COLUMN] = $META;
$HEADERS[$COLUMN] = $HEADER;
}

################## SetGlobalsForMetaRow #################
# Set globals: @{$MTABLE->[$MROW]}
# They are relative to $MROW, which must already be set.
sub SetGlobalsForMetaRow
{
defined($MTABLE) || confess "Died";
defined($MROW) || confess "Died";
($DIRECTIVE, $ARGS, @METAS) = @{$MTABLE->[$MROW]};
$DIRECTIVE || confess "Died";
@METAS || confess "Died";
@HEADERS == @METAS || confess "Died";
}

################## ResetGlobalsForMetaRow #################
# Reset globals: @{$MTABLE->[$MROW]}
# They are relative to $MROW, which must already be set.
sub ResetGlobalsForMetaRow
{
defined($MROW) || confess "Died";
$DIRECTIVE || confess "Died";
@METAS || confess "Died";
@HEADERS == @METAS || confess "Died";
@{$MTABLE->[$MROW]} = ($DIRECTIVE, $ARGS, @METAS);
}

################## SetGlobalsForDataRow #################
# Set globals: %DATA
# They are relative to $ROW, which must already be set.
sub SetGlobalsForDataRow
{
defined($ROW) || confess "Died";
defined($NCOLUMNS) || confess "Died";
@HEADERS || confess "Died";
for (my $i=0; $i<$NCOLUMNS; $i++) {
	$DATA{$HEADERS[$i]} = $TABLE->[$ROW]->[$i];
	}
}

################## ResetGlobalsForDataRow #################
# Reset globals that are relative to $ROW, which must already be set.
sub ResetGlobalsForDataRow
{
defined($ROW) || confess "Died";
defined($NCOLUMNS) || confess "Died";
@HEADERS || confess "Died";
# Noop because %DATA is read only:
return;
for (my $i=0; $i<$NCOLUMNS; $i++) {
	$TABLE->[$ROW]->[$i] = $DATA{$HEADERS[$i]};
	}
}

################## SetGlobalsForDataColumn #################
# Set globals: $HEADER, $_
# They are relative to $COLUMN, which must already be set.
# The $ROW must already be set also.
sub SetGlobalsForDataColumn
{
defined($ROW) || confess "Died";
defined($COLUMN) || confess "Died";
defined($NCOLUMNS) || confess "Died";
@HEADERS || confess "Died";
$HEADER = $HEADERS[$COLUMN];
defined($HEADER) || confess "Died";
$_ = $TABLE->[$ROW]->[$COLUMN];
defined($_) || confess "Died";
}

################## ResetGlobalsForDataColumn #################
# Reset globals: $HEADER, $_
# They are relative to $COLUMN, which must already be set.
# The $ROW must already be set also.
sub ResetGlobalsForDataColumn
{
defined($ROW) || confess "Died";
defined($COLUMN) || confess "Died";
defined($NCOLUMNS) || confess "Died";
@HEADERS || confess "Died";
defined($HEADER) || confess "Died";
$HEADERS[$COLUMN] = $HEADER;
defined($_) || confess "Died";
$TABLE->[$ROW]->[$COLUMN] = $_;
}

################## Iterate #################
# Iterates through the meta cells if $fPerMetaCell is set,
# and through data cells if $fPerDataCell is set.
# $MROW must already be set. 
sub Iterate
{
my ($fPerMetaCell, $fPerDataCell) = @_;
# &SetGlobalsForMetaRow();
if ($fPerMetaCell) {
	for ($COLUMN=0; $COLUMN<$NCOLUMNS; $COLUMN++) {
		&SetGlobalsForMetaColumn();
		&{$fPerMetaCell}();
		&ResetGlobalsForMetaColumn();
		}
	}
if ($fPerDataCell) {
	for ($ROW=0; $ROW<$NROWS; $ROW++) {
		&SetGlobalsForDataRow();
		for ($COLUMN=0; $COLUMN<$NCOLUMNS; $COLUMN++) {
			&SetGlobalsForMetaColumn();
			&SetGlobalsForDataColumn();
			&{$fPerDataCell}();
			&ResetGlobalsForDataColumn();
			&ResetGlobalsForMetaColumn();
			}
		}
		&ResetGlobalsForDataRow();
	}
# &ResetGlobalsForMetaRow();
}

################## Perl_PreRun #################
# Process all data rows for the current meta row $MROW.
# Called as:
#   $MROW = ...
#   &Perl_PreRun()
sub Perl_PreRun
{
my $oldDebug = $debug;
# $debug = 2;
warn "Perl_PreRun starting:  ARGS: $ARGS MROW: $MROW\n" if $debug > 1;
# Nothing to be done per meta cell:
my $fPerMetaCell = undef;
my $fPerDataCell = sub {
	# Run $ARGS on every cell
	my $saveUnderscore = $_;	# Do not overwrite $_
	if ($ARGS ne "") {
		warn "Perl_PreRun ARGS: {$ARGS} ROW: $ROW COLUMN: $COLUMN\n" if $debug > 1;
		&EvalWarnings($ARGS);
		}
	$_ = $saveUnderscore;		# Restore $_
	if ($META ne "") {
		warn "Perl_PreRun META: {$META} ROW: $ROW COLUMN: $COLUMN\n" if $debug > 1;
		&EvalWarnings($META);
		}
	$_ = $saveUnderscore;		# Restore $_
	};
&Iterate($fPerMetaCell, $fPerDataCell);
$debug = $oldDebug;
}

################## Perl_Filter #################
sub Perl_Filter
{
warn "Called Perl_Filter(@_) UNDERBAR: $_ META: $META ARGS: $ARGS\n" if $debug > 1;
$_ = &EvalWarnings($ARGS) if $ARGS ne "";
defined($_) || die "$0: [ERROR] Eval of ARGS {$ARGS} failed: $?\n";
warn "  After eval(ARGS) UNDERBAR: $_\n" if $debug > 1;
$_ = &EvalWarnings($META) if $META ne "";
defined($_) || die "$0: [ERROR] Eval of META {$META} failed: $?\n";
warn "  Done Perl_Filter(@_) UNDERBAR: $_ ARGS: $ARGS\n" if $debug > 1;
}

################## Echo #################
# Print a triple for each cell in the table, using the current 
# subject $S, the current predicate $P and the current cell value $_ .
sub Echo
{
warn "Called Echo(@_)\n" if $debug > 1;
my $v = $_;
return if !$S || !$P || !defined($v) || $v eq "";
# Auto-quote strings:
# TODO: Fix.  Not right for numbers.
if ($v !~ m/^"/) {
	my $oldv = $v;
	if ($v =~ s/\"/ /g) {
		warn "$0: [WARNING] Embedded quotes changed to spaces: \"$oldv\"\n";
		}
	$v = "\"$v\"";
	}
print "$S $P $v .\n";
return $_;
}

################## Class #################
# Sets $CLASS{$HEADER}
# Called as:
#   &Class($args, @fields);
# where @fields are meta fields, not data fields, because #Class is
# a preprocessing directive.
sub Class
{
die "UNFINISHED ";
# Process $ARGS the same as any other field:
my @fields = ($ARGS, @METAS);
my $oldDebug = $debug;
$debug = 2;
for (my $i=0; $i<@fields; $i++) {
	my $f = $fields[$i];
	next if $f !~ m/\S/;
	$f = &Trim($f);
	# Ignore optional "@prefix" and trailing period:
	$f =~ s/^\@//;
	$f =~ s/^prefix\s+//i;
	$f =~ s/\s*\.$//;
	my ($prefix, $uri, @extra) = split(/\s+/, $f, -1);
	die "$0: [ERROR] Class: Bad declaration: $fields[$i]\n"
		if @extra || !$uri || $prefix !~ m/\:$/;
	# Remove optional <..> around the URI template:
	my $bareUri = $uri;
	$bareUri =~ s/^\<(.*)\>$/$1/;
	my ($eUri, $undefVar) = &ExpandUriTemplate($bareUri, %uriTemplateValues);
	die "$0: [ERROR] Class: Undefined variable $undefVar in URI template: $bareUri\n" if $undefVar;
	$NAMESPACE{$prefix} = "<$eUri>";
	warn "  PREFIX: $prefix <$eUri>\n" if $debug > 1;
	}
$debug = $oldDebug;
# die "STOPPED!\n";
}

################## Prefix #################
# Called as:
#   &Prefix($args, @fields);
# where @fields are meta fields, not data fields, because #Prefix is
# a preprocessing directive.
sub Prefix
{
# Process $ARGS the same as any other field:
my @fields = ($ARGS, @METAS);
my $oldDebug = $debug;
# $debug = 2;
for (my $i=0; $i<@fields; $i++) {
	my $f = $fields[$i];
	next if $f !~ m/\S/;
	$f = &Trim($f);
	# Ignore optional "@prefix" and trailing period:
	$f =~ s/^\@//;
	$f =~ s/^prefix\s+//i;
	$f =~ s/\s*\.$//;
	my ($prefix, $uri, @extra) = split(/\s+/, $f, -1);
	die "$0: [ERROR] Prefix: Bad declaration: $fields[$i]\n"
		if @extra || !$uri || $prefix !~ m/\:$/;
	# Remove optional <..> around the URI template:
	my $bareUri = $uri;
	$bareUri =~ s/^\<(.*)\>$/$1/;
	my ($eUri, $undefVar) = &ExpandUriTemplate($bareUri, %uriTemplateValues);
	die "$0: [ERROR] Prefix: Undefined variable $undefVar in URI template: $bareUri\n" if $undefVar;
	$NAMESPACE{$prefix} = "<$eUri>";
	warn "  PREFIX: $prefix <$eUri>\n" if $debug > 1;
	}
$debug = $oldDebug;
# die "STOPPED!\n";
}

################## SetUriTemplateVariable #################
# Set %uriTemplateValues, for use in URI Templates.
sub SetUriTemplateVariable
{
# Process $ARGS the same as any other field:
my @fields = ($ARGS, @METAS);
my $oldDebug = $debug;
# $debug = 2;
for (my $i=0; $i<@fields; $i++) {
	my $f = $fields[$i];
	next if $f !~ m/\S/;
	$f = &Trim($f);
	my @varVal = split(/\s+/, $f, -1);
	$COLUMN = $i-1;
	die "[ERROR] SetUriTemplateVariable: Odd number of components at meta row $MROW column $COLUMN: $f\n" if (@varVal % 2) != 0;
	while(@varVal) {
		my $var = shift @varVal;
		my $rawVal = shift @varVal;
		warn "[WARNING] SetUriTemplateVariable: Variable $var redeclared at meta row $MROW column $COLUMN: $f\n" if exists($uriTemplateValues{$var});
		# The value itself may be a template that needs expansion:
		# 	foo http://example/{bar}/baz
		my ($val, $undefVar) = &ExpandUriTemplate($rawVal, %uriTemplateValues);
		die "[ERROR] SetUriTemplateVariable: Undefined variable $undefVar found in URI template expression $rawVal at meta row $MROW column $COLUMN\n" if $undefVar;
		$uriTemplateValues{$var} = $val;
		warn "SetUriTemplateVariable var: $var value: $val\n" if $debug > 1;
		}
	}
if ($debug > 1) {
	use Data::Dumper;
	warn "uriTemplateValues = \n";
	my $d = &Dumper(\%uriTemplateValues);
	warn "$d\n";
	}
$debug = $oldDebug;
# die "STOPPED!\n";
}

############### ExpandUriTemplate ###############
# Usage:
#   my ($value, $undefVar) = &ExpandUriTemplate($expr, %varValMappings);
# Where $undefVar will be the name of an undefined variable in $expr
# if it has any that are undefined.   If all variables in $expr
# are defined in %varValMappings then $undefVar will be the empty string.
sub ExpandUriTemplate
{
@_ >= 1 || confess "Died";
my $expr = shift;
my %varValMappings = @_;
my $template = URI::Template->new( $expr );
my @variables = $template->variables();
warn "ExpandUriTemplate EXPR: $expr VARIABLES: @variables\n" if $debug > 1;
foreach my $v (@variables) {
	warn "  EXPR: $expr VARIABLE: $v\n" if $debug > 1;
	# Return error if any variable in $expr is undefined
	return("", $v) if !exists($varValMappings{$v});
	}
if (0) {
	foreach my $tvar (sort keys %varValMappings) {
		my $tval = $varValMappings{$tvar};
		warn "  VAR: $tvar VAL: $tval\n" if $debug > 1;
		}
	}
my $val      = $template->process( %varValMappings )->as_string;
return($val, "");
}

################## Perl_Run #################
sub Perl_Run
{
my $saveUnderbar = $_;
my $shouldWarn = $debug && ($ARGS || $META);
warn "Called Perl_Run(@_) UNDERBAR: $_ META: $META ARGS: $ARGS\n" if $shouldWarn;
my $result = "";
$result = &EvalWarnings($ARGS) if $ARGS ne "";
my $e = $@ || $! || $?;
warn "  Perl_Run After eval(ARGS) UNDERBAR: $_\n" if $shouldWarn;
$_ = $saveUnderbar;
$e = $@ || $! || $?;
$result = &EvalWarnings($META) if $META ne "";
warn "  Perl_Run After eval(META) UNDERBAR: $_\n" if $shouldWarn;
$_ = $saveUnderbar;
warn "  Perl_Run Done Perl_Filter(@_) UNDERBAR: $_ ARGS: $ARGS\n" if $shouldWarn;
}

################# EvalWarnings ##################
# Run eval while trapping warnings, and return the eval result.
# Warnings and errors are reported.  Old eval errors are cleared first.
# Usage:
#   my $result = &EvalWarnings($expr);
sub EvalWarnings
{
@_ == 1 || confess "Died";
my $expr = shift @_;
$expr || confess "Died";
# warn "EvalWarnings starting expr: {$expr}\n" if $debug > 1;
my $result;
my $warning = "";
# Clear old errors prior to eval.  $@ does not need to be cleared.
$! = 0;
$? = 0;
#### Create a new scope for trapping warnings.
#### DO NOT TRY TO CALL warn FROM THIS SCOPE!
	{
	local $SIG{__WARN__} = sub {
		$warning .= (shift || "");
		};
	$result = eval $expr;
	}
my $error = $@ || "";
# warn "EvalWarnings after eval, warning: {$warning} error: {$error}\n" if $debug > 1;
if ($warning) {
	my $directive = $DIRECTIVE || "INTERNAL";
	my $args = $ARGS || "(undef)";
	my $mrow = (defined($MROW) ? $MROW : "(undef)");
	my $header = (defined($COLUMN) ? $ORIGINAL_HEADERS[$COLUMN] : undef);
	my $cell = (defined($COLUMN) && defined($ROW) 
		? $TABLE->[$ROW]->[$COLUMN] : undef);
	my $msg = "[WARNING] $directive: eval of {$expr} at meta row $mrow";
	$msg .= " column $COLUMN {$header}" if defined($COLUMN);
	$msg .= " meta cell {$META}" if defined($META);
	$msg .= " data row $ROW" if defined($ROW);
	$msg .= " data cell {$cell}" if defined($cell);
	$msg .= " produced a warning: $warning\n";
	warn $msg;
	}
if ($error) {
	my $directive = $DIRECTIVE || "INTERNAL";
	my $args = $ARGS || "(undef)";
	my $mrow = (defined($MROW) ? $MROW : "(undef)");
	my $header = (defined($COLUMN) ? $ORIGINAL_HEADERS[$COLUMN] : undef);
	my $cell = (defined($COLUMN) && defined($ROW) 
		? $TABLE->[$ROW]->[$COLUMN] : undef);
	my $msg = "[ERROR] $directive: eval of {$expr} at meta row $mrow";
	$msg .= " column $COLUMN {$header}" if defined($COLUMN);
	$msg .= " meta cell {$META}" if defined($META);
	$msg .= " data row $ROW" if defined($ROW);
	$msg .= " data cell {$cell}" if defined($cell);
	$msg .= " produced an error: $error\n";
	die $msg;
	}
return $result;
}

################# RemoveMetadataRows ##################
# Destructively remove and return metadata rows from the given data table.
# Metadata rows are returned as a ref to an array of row refs -- the
# same form as the given data table.  The metadata directive is
# the first cell in each metadata row.  The #META column is removed
# entirely from the data table.  
sub RemoveMetadataRows
{
my $tsv = shift @_ || confess "Died";
my $meta = [];
my $firstCellValue = $tsv->[0]->[0];
defined($firstCellValue) || die "$0: [ERROR] Table has no header row!\n";
# warn "firstCellValue: {$firstCellValue}\n";
return $meta if $firstCellValue ne "#META";
# Temporarily remove the header row:
my $headers = shift @{$tsv};
# Get rid of "#META" header cell:
shift @{$headers};
# Grab the metadata rows:
while (@{$tsv} && $tsv->[0]->[0] =~ s/^\#(\S*)\s*//) {
	my $directive = $1;
	my $row = shift @{$tsv};
	# warn "REMOVED ROW: @{$row}\n";
	next if $directive eq "" || $directive =~ m/^\#/;
	my $args = shift @{$row};
	push(@{$meta}, [ $directive, $args, @{$row} ]);
	}
# Put back the header row:
unshift(@{$tsv}, $headers);
# Strip the #META column from all the data rows:
for (my $i=1; $i<@{$tsv}; $i++) {
	shift @{$tsv->[$i]};
	}
return $meta;
}

############### PrintTable ###############
sub PrintTable
{
my $tsv = shift @_ || confess "Died";
foreach my $row (@{$tsv}) {
	my $line = join("\t", @{$row});
	print "$line\n";
	}
}

########## ReadTsv ###########
# Read a TSV file from a filename (if given) or stdin,
# trimming leading and trailing whitespace from all cells.
# Returns a reference to an array (the rows) of array 
# references (the column values).  The result is guaranteed
# to have the same number of cells in each row.
sub ReadTsv
{
@_ <= 1 or confess "Died";
my $f = shift @_ || "";
my $fh = \*STDIN;
!$f || open($fh, "<$f") || die "$0: [ERROR] Cannot open $f\n";
my $result = [];
my $nColumns = 0;
my $row = 0;
while (my $line = <$fh>) {
	chomp $line;
	my @fields = map {&Trim($_)} split(/\t/, $line, -1);
	@fields || die "$0: [ERROR] No data fields found in " . ($f ? "STDIN" : $f) . "\n";
	my $nf = scalar(@fields);
	$nColumns = $nf if !$nColumns;
	$nf == $nColumns || die "$0: [ERROR] Number of data columns ($nf) does not match the number of header columns ($nColumns) on data row $row in " . ($f ? "STDIN" : $f) . "\n";
	# warn "\tRead $nf columns\n";
	push(@{$result}, [ @fields ] );
	$row++;
	}
!$f || close($fh);
# warn "Read $row rows\n";
return $result;
}

########## Trim ############
# Perl function to remove whitespace from beginning and end of a string.
sub Trim
{
my $s = shift @_;
$s =~ s/\A[\s\n\r]+//s;
$s =~ s/[\s\n\r]+\Z//s;
return $s;
}

########## Clean ###########
# Trim leading and trailing whitespace, turn everything but [a-zA-Z0-9_]
# into underscore ("_") and change any occurrences of multiple
# underscores into a single underscore.
sub Clean
{
my $v = shift @_ || confess "Died";
$v = &Trim($v);
$v =~ s/[^A-Za-z0-9_]/_/g;
$v =~ s/_+/_/g;
return $v;
}

########## MakeVar ###########
# Turn the given column name into a variable,
# or return the empty string if failure.
sub MakeVar
{
my $v = shift @_ || confess "Died";
$v = &Clean($v);
# $v =~ s/_$//;
# $v =~ s/^_//;
$v = "" if $v !~ m/^[A-Za-z]/;	# Must start with a letter
return $v;
}

