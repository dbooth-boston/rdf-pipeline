#! /usr/bin/env perl

# Copyright 2015 by David Booth
# This software is available as free and open source under
# the Apache 2.0 software license, which may be viewed at
# http://www.apache.org/licenses/LICENSE-2.0.html
# Code home: https://github.com/dbooth-boston/rdf-pipeline/

# Convert TSV to RDF.  
# Empty cells are skipped -- they do not generate triples.
# Reads stdin, writes stdout.
#
# Regression test for this code is @@ TODO @@ .

# TODO: Include headers in metadata table.
#
# TODO: Add a --guess option to guess column data types
# and primary key.  If multiple columns are candidate keys
# (i.e., have unique values) then weights might be used
# to choose, based on:
#	- earlier column in the table;
#	- column datatype;
#	- column with only positive integers, versus other content;
#	- column name ends with "ID"; 
#	- column values are the same or similar length.
# However, it is easy enough to specify which column is the
# primary key, so we probably should not get overly sophisticated
# in guessing the primary key.   Maybe the primary key column
# could be specified as a pattern (or substring or initial substring) 
# to accommodate minor changes in column names.  For example, 
# a '--primaryKey=foo' option might select the first column whose 
# name contains "foo", and '--primaryKey=^foo$' would have to
# match the whole column name.

##################################################################

use warnings;
use strict;
use Carp;

# Devel::NYTProf can be used for performance profiling.
# To use it:
#    export NYTPROF='sigexit=1'
#    perl -d:NYTProf -- `which tsv2rdf` -m metadata-consolidated.xlsx -F xlsx junk100.xlsx > demo.ttl
# For a 3600 row spreadsheet, profiling everything, 
# it increased the runtime (up through
# reading the metadata and data files, but not processing them)
# from 15 seconds to 65 seconds.  Since we cannot control the module
# that reads xlsx spreadsheets, the $fasterProfiling variable below controls
# the disabling of profiling during xlsx spreadsheet parsing, and
# reduced the above time to 20 seconds.
our $fasterProfiling = 1;

$fasterProfiling = 0 if !defined(&DB::enable_profiling);
DB::enable_profile() if $fasterProfiling;

use URI::Template;
use Encode qw( decode encode );

################# Usage ###################
sub Usage
{
return "Usage: $0 [ options ] [ file.ext ... ]
Options:
  -b, --base=baseUri
	Use baseUri as the base in generating URIs.

  -m, --meta=metadataFile.tsv
	Use metadata from metadataFile.tsv instead of metadata
	embedded in input file.  If this option is used, any metadata
	extracted from input file is discarded.

  -w, --worksheet=W
	Extract data table from worksheet W, which may either be the
	name of a worksheet or a 0-based worksheet index.  Default: 0

  -W, --metaWorksheet=W
	Extract metadata table from worksheet W.

  -f, --format=fmt
	Data file has format fmt, which is case insensitive 
	and must be one of:
		tsv	(Tab Separated Values)
		csv	(Comma Separated Values)
		xlsx	(Excel xlsx format)
		xls	(Excel xls format)
	If this argument is not specified the data file's extension
	is used to guess the data format.  

  -F, --metaFormat=fmt
	Metadata file has format fmt, where the acceptable formats
	are the same as for the -f option.

  -t, --trim  
	Trim leading and trailing whitespace from all cells when 
	reading data and metadata tables.  Leading and trailing
	whitespace is always trimmed from the header row, so this
	option only affects non-header rows.  DEFAULT
	Opposite: --no-trim

  --keepEmptyTrailingColumns
	Keep trailing (right-most) columns whose header and cells contain 
	only whitespace.  By default they are ignored.

  --keepEmptyTrailingRows
	Keep trailing (bottom-most) rows whose cells contain 
	only whitespace.  By default they are ignored.

  --requireVersion v
	Require at least version v.
	NOT YET IMPLEMENTED.

  -d, --debug
	Print debugging info.  Intended for developers only.
	This option may be repeated for more verbose debugging output.

  -h, --help
	Print this usage message.

where infile.ext contains the input data table and (optionally) embedded
metadata.  Embedded metadata is removed from the data table prior
to processing.  If infile.ext is not specified, STDIN will be read.
Normally the file extension indicates file format, but the -w or -W
options can be used to override file extensions.
";
}

##################################################################
################# Main ###################
##################################################################

########### Globals
our $MTABLE;	# Ref to the entire metadata table.  Each row contains:
		#   ($DIRECTIVE, $ARGS, @METAS)
our $TABLE;	# Ref to the entire data table
our $RTABLE;	# Ref to the entire raw data table
our @PENDING;	# Rows pending, used by #Filter for splitting rows
our @HEADERS;	# Column headers (excluding any #META column header)
our $HEADER;	# Current header: $HEADER[$COLUMN]
our $RAW;	# Current original cell value.  Corresponds to $_
our %NAMESPACE;	# Prefix->namespace mappings
our $MROW;	# Index of current meta row
our $ROW;	# Index of current data row
our $COLUMN;	# Index of current meta/data/header column
our $DIRECTIVE;	# Directive parsed from #META column of current $MROW
our $ARGS;	# Args parsed from #META column of current $MROW
our @METAS;	# Meta cell values for current $MROW
our $META;	# Meta cell value for current $MROW and $COLUMN
our %DATA;	# Maps column name to cell value in current row
our $S;		# Turtle subject of current data $ROW
our $P;		# Turtle property of current $COLUMN
our @PS;	# Turtle properties of all columns
########### Other globals, probably not used by users
our $NROWS;	# Number of data rows (excludes header row)
our $NMROWS;	# Number of meta rows (excludes header row)
our $NCOLUMNS;	# Number of data columns (and meta columns and headers)
########### To be made obsolete probably:
our %HEADER_TO_COLUMN;	# Maps header to column index
our %KEY_TO_ROW;	# Maps header to column hash to row number (0 based)
our %PK_TO_ROW;		# Maps $PRIMARY_KEY column hash to row number (0 based)
our $PRIMARY_KEY;	# Header name of primary key column

# Map file extensions (lower case) to readers:
my %readerForFormat = qw(
	tsv	ReadTsv
	xlsx	ReadXlsx
	);

my $baseUri = "http://example/";
my $help = 0;
my $debug = 0;
my $metadataFile = "";
my $worksheet = "";
my $metaWorksheet = "";
my $format = "";
my $metaFormat = "";
my $infile = "";
my $trim = 1;
my $keepEmptyTrailingColumns = 0;
my $keepEmptyTrailingRows = 0;
my $requireVersion = "";
use Getopt::Long qw(:config no_ignore_case bundling);
GetOptions(
                "debug|d+" => \$debug,
                "help|h" => \$help,
                "base|b=s" => \$baseUri,
                "worksheet|w=s" => \$worksheet,
                "metaWorksheet|W=s" => \$metaWorksheet,
                "meta|m=s" => \$metadataFile,
                "format|f=s" => \$format,
                "metaFormat|F=s" => \$metaFormat,
                "trim|t!" => \$trim,
		"keepEmptyTrailingColumns!" => \$keepEmptyTrailingColumns,
		"keepEmptyTrailingRows!" => \$keepEmptyTrailingRows,
                "requireVersion=s" => \$requireVersion,
                ) or die "$0: Error reading options.  " . &Usage();

warn "$0: [WARNING] Option not yet implemented: --requireVersion\n"
	if $requireVersion;
die &Usage() if $help;
$baseUri || die &Usage();
die &Usage() if @ARGV > 1;
$infile = $ARGV[0] if @ARGV;


$RTABLE = &ReadTable($infile, $worksheet, $format); 

# warn "======================= DATA table ======================\n" if $debug;
# &PrintTable($RTABLE) if $debug;
# warn "==========================================================\n" if $debug;
# warn "\n" if $debug;
# die "Done\n";

$MTABLE = &RemoveMetadataRows($RTABLE);
# print "======================= META table ======================\n" if $debug;
# &PrintTable($MTABLE) if $debug;
# print "==========================================================\n" if $debug;


my $headersRef = shift @{$RTABLE};
@HEADERS = @{$headersRef};
for (my $r=0; $r<@{$RTABLE}; $r++) {
	@{$TABLE->[$r]} = @{$RTABLE->[$r]};
	}

if ($metadataFile) {
	warn "Reading separate metadataFile: $metadataFile\n" if $debug;
	my $rawMeta = &ReadTable($metadataFile, $metaWorksheet, $metaFormat);
	$MTABLE = &RemoveMetadataRows($rawMeta);
	# Make sure the metadata headers match the data headers.
	my $metaHeadersRef = ${$rawMeta}[0];
	$metaHeadersRef || die "$0: [ERROR] metadataFile has no header row: $metadataFile\n";
	my @metaHeaders = @{$metaHeadersRef};
	my $nmh = scalar(@metaHeaders);
	my $nh = scalar(@HEADERS);
	for (my $i=0; $i<@metaHeaders && $i<@HEADERS; $i++) {
		$metaHeaders[$i] eq $HEADERS[$i] || die "$0: [ERROR] Metadata header ($metaHeaders[$i]) in column $i does not match data header ($HEADERS[$i]) in corresponding data column.\n";
		}	
	if ($nmh > $nh) {
		my $nExtras = $nmh - $nh;
		my $extras = join("|", @metaHeaders[ $#HEADERS+1 .. $#metaHeaders ] );
		die "$0: [ERROR] $nExtras extra metadata columns: $extras\n";
		}
	elsif ($nmh < $nh) {
		my $nExtras = $nh - $nmh;
		my $extras = join("|", @HEADERS[ $#metaHeaders+1 .. $#HEADERS ] );
		die "$0: [ERROR] $nExtras extra data columns: $extras\n";
		}
	}

# Trim all metadata cells:
for (my $r=0; $r<@{$MTABLE}; $r++) {
	@{$MTABLE->[$r]} = map {&Trim($_)} @{$MTABLE->[$r]};
	}

# print "======================= META table ======================\n" if $debug;
# &PrintTable($MTABLE) if $debug;
# print "==========================================================\n" if $debug;
# warn "\n" if $debug;
# print "======================= DATA table ======================\n" if $debug;
# &PrintTable($TABLE) if $debug;
# print "==========================================================\n" if $debug;
# print "\n" if $debug;
# exit 0;

{
no warnings qw(qw);
%NAMESPACE = qw(
	rdf:	<http://www.w3.org/1999/02/22-rdf-syntax-ns#>
	dc:	<http://purl.org/dc/elements/1.1/>
	rdfs:	<http://www.w3.org/2000/01/rdf-schema#>
	owl:	<http://www.w3.org/2002/07/owl#>
	xsd:	<http://www.w3.org/2001/XMLSchema#>
	);
}

my %VAR;	# For #SetVar.  Variables to be declared "our"
my %REFS;	# Maps var name (as string) to its reference.
my %MAGIC;	# For "$svar in %var" or "$svar in @var".  Maps $svar to %/@var

my %isPreProcessingDirective = map {($_,1)} qw( 
	Prefix 
	SetVar
	Perl_PreRun
	);

my %isPostProcessingDirective = map {($_,1)} qw( 
	End
	);

$NROWS = scalar(@$TABLE);
$NCOLUMNS = scalar(@HEADERS);
$NMROWS = scalar(@{$MTABLE});

# Pre-processing directives 
for ($MROW=0; $MROW<@{$MTABLE}; $MROW++) {
	# ($DIRECTIVE, $ARGS, @METAS) = @{$mr};
	&SetMetaGlobalsForMRow();
	next if !$isPreProcessingDirective{$DIRECTIVE};
	warn "BEGIN Preprocessing DIRECTIVE: $DIRECTIVE ARGS: $ARGS MROW: $MROW METAS: @METAS\n" if $debug > 0;
	no strict 'refs';
	&{$DIRECTIVE}();	# All args are passed as globals
	warn "END Preprocessing DIRECTIVE: $DIRECTIVE ARGS: $ARGS MROW: $MROW METAS: @METAS\n" if $debug > 1;
	}

# Output namespaces.
foreach my $prefix (sort keys %NAMESPACE) {
	print "\@prefix $prefix\t$NAMESPACE{$prefix} .\n";
	}
print "\n";

# Set up maps/indexes.
warn "NCOLUMNS: $NCOLUMNS NROWS: $NROWS headers: @HEADERS\n" if $debug;
for ($COLUMN=0; $COLUMN<$NCOLUMNS; $COLUMN++) {
	$HEADER_TO_COLUMN{$HEADERS[$COLUMN]} = $COLUMN;
	}
for ($ROW=0; $ROW<$NROWS; $ROW++) {
	for ($COLUMN=0; $COLUMN<$NCOLUMNS; $COLUMN++) {
		# For PK 'PROJECT ID' value 'P001' in first row:
		# $KEY_TO_ROW{'PROJECT ID'}->{'P001'} = 0;
		$KEY_TO_ROW{$HEADERS[$COLUMN]}->{$TABLE->[$ROW][$COLUMN]} = $ROW;
		$PK_TO_ROW{$TABLE->[$ROW][$COLUMN]} = $ROW
			if defined($PRIMARY_KEY) && $HEADERS[$COLUMN] eq $PRIMARY_KEY;
		}
	}

@PS = map {
	my $p = &MakeVar($HEADERS[$_]) || "UNDEFINED$_";
	"table:$p" } (0 .. $#HEADERS);
# Process all data rows.
my $isFirstRow = 1;
for ($ROW=0; $ROW<$NROWS; $ROW++) {
    # next if $ROW != 2;
    warn "================= DATA ROW ====================\n" if $debug;
    warn " ROW $ROW: @{$TABLE->[$ROW]}\n" if $debug;
    warn "===============================================\n" if $debug;
    @PENDING = ();
    while (1) {
	&SetDataGlobalsForRow();
	for ($MROW=0; $MROW<@{$MTABLE}; $MROW++) {
		my $mr = $MTABLE->[$MROW];
		# ($DIRECTIVE, $ARGS, @METAS) = @{$mr};
		&SetMetaGlobalsForMRow();
		$DIRECTIVE || confess "Died";
		# Preprocessing directives have already been handled, so skip:
		next if $isPreProcessingDirective{$DIRECTIVE};
		next if $isPostProcessingDirective{$DIRECTIVE};
		my $option = "";
		$option = $1 if ($ARGS =~ s/^(ifdata|once)\b\s*//);
		my $ifdata = ($option eq "ifdata");
		my $once = ($option eq "once");
		next if $once && !$isFirstRow;
		@METAS || confess "Died";
		@HEADERS == @METAS || confess "Died";
		warn "--------------- META --------------------\n" if $debug;
		warn "Directive: $DIRECTIVE ARGS: $ARGS METAS: @METAS\n" if $debug;
		warn "UNDERSCORE: $_\n" if $debug > 1;
		for ($COLUMN=0; $COLUMN<$NCOLUMNS; $COLUMN++) {
			# Skip $ifdata and $_ is empty?
			next if $ifdata && $TABLE->[$ROW]->[$COLUMN] eq "";
			&SetMetaGlobalsForColumn();
			&SetDataGlobalsForColumn();
			no strict 'refs';
			defined(&{$DIRECTIVE}) || die "$0: [ERROR] No function $DIRECTIVE defined for directive: #$DIRECTIVE\n";
			# warn "LOOP Calling &$DIRECTIVE() UNDERBAR: $_ ARGS: $ARGS META: $META;\n" if $META =~ m/properties/ || $debug > 1;
			my $oldUnderbar = $_;
			&{$DIRECTIVE}();
			warn "Done calling &$DIRECTIVE();\n" if $debug > 1;
			&ResetDataGlobalsForColumn();
			}
		}
	$isFirstRow = 0;
	# Repeat this row because #Filter added pending rows?
	last if !@PENDING;
	$TABLE->[$ROW] = shift @PENDING;
	}
    }

# Post-processing directives 
for ($MROW=0; $MROW<@{$MTABLE}; $MROW++) {
	# ($DIRECTIVE, $ARGS, @METAS) = @{$mr};
	&SetMetaGlobalsForMRow();
	next if !$isPostProcessingDirective{$DIRECTIVE};
	warn "BEGIN Postprocessing DIRECTIVE: $DIRECTIVE ARGS: $ARGS MROW: $MROW METAS: @METAS\n" if $debug > 0;
	no strict 'refs';
	&{$DIRECTIVE}();	# All args are passed as globals
	warn "END Postprocessing DIRECTIVE: $DIRECTIVE ARGS: $ARGS MROW: $MROW METAS: @METAS\n" if $debug > 1;
	}

exit 0;


#####################################################################
######################### END OF MAIN ###############################
#####################################################################

################## CellFilter ###################
# Filter all meta and data cells through this function, applying global options.
sub CellFilter
{
@_ == 1 || confess "Died";
my ($v) = @_;
$v = encode( 'utf-8', $v );
if ($trim) {
	$v = &Trim($v);
	}
return $v;
}

################## SetMetaGlobalsForColumn #################
# Set globals: $P $HEADER and maybe $META.
# from @PS $METAS[$COLUMN] and $HEADERS[$COLUMN].
# They are relative to $COLUMN, which 
# must already be set.  @METAS must already be set also,
# as by calling SetMetaGlobalsForMRow.
sub SetMetaGlobalsForColumn
{
defined($COLUMN) || confess "Died";
($COLUMN>=0 && $COLUMN<$NCOLUMNS) || confess "Died";
@HEADERS || confess "Died";
$META = $METAS[$COLUMN];
$META = "" if !defined($META);
$META = "" if $MROW<0 || $MROW>=$NMROWS;
$HEADER = $HEADERS[$COLUMN];
defined($HEADER) || confess "Died";
$P = $PS[$COLUMN];
}

################## SetMetaGlobalsForMRow #################
# Set globals: @{$MTABLE->[$MROW]}
# They are relative to $MROW, which must already be set.
sub SetMetaGlobalsForMRow
{
defined($MTABLE) || confess "Died";
defined($MROW) || confess "Died";
($DIRECTIVE, $ARGS, @METAS) = @{$MTABLE->[$MROW]};
$DIRECTIVE || confess "Died";
@METAS || confess "Died";
my $nHeaders = scalar(@HEADERS);
my $nMetas = scalar(@METAS);
@HEADERS == @METAS || confess "Died. nHeaders: $nHeaders nMetas: $nMetas
 METAS:
 @METAS
 HEADERS:
 @HEADERS
 ";
}

################## SetDataGlobalsForRow #################
# Set globals: %DATA
# They are relative to $ROW, which must already be set.
sub SetDataGlobalsForRow
{
defined($ROW) || confess "Died";
($ROW>=0 && $ROW<$NROWS) || confess "Died";
defined($NCOLUMNS) || confess "Died";
@HEADERS || confess "Died";
for (my $i=0; $i<$NCOLUMNS; $i++) {
	$DATA{$HEADERS[$i]} = $TABLE->[$ROW]->[$i];
	# Clear old magic vars for safety:
	%MAGIC = ();
	}
$S = "_:row$ROW";
}

################## SetDataGlobalsForColumn #################
# Set globals: $HEADER $_ $RAW
# They are relative to $COLUMN, which must already be set.
# The $ROW must already be set also.
sub SetDataGlobalsForColumn
{
defined($ROW) || confess "Died";
defined($COLUMN) || confess "Died";
defined($NCOLUMNS) || confess "Died";
($COLUMN>=0 && $COLUMN<$NCOLUMNS) || confess "Died";
# Important to set $RAW and $_ before eval'ing
# that may involve $RAW and $_.
$RAW = $RTABLE->[$ROW]->[$COLUMN];
# $_ = $TABLE->[$ROW]->[$COLUMN];
$_ = $DATA{$HEADER};
defined($_) || confess "Died";
}

################## ResetDataGlobalsForColumn #################
# Reset globals: $_ 
# They are relative to $COLUMN, which must already be set.
# The $ROW must already be set also.
sub ResetDataGlobalsForColumn
{
defined($ROW) || confess "Died";
defined($COLUMN) || confess "Died";
defined($NCOLUMNS) || confess "Died";
($COLUMN>=0 && $COLUMN<$NCOLUMNS) || confess "Died";
defined($_) || confess "Died: Undefined value in \$_ ";
$TABLE->[$ROW]->[$COLUMN] = $DATA{$HEADER} = $_;
}

################## MatchesLiteral ##################
# Does $term seem to be a Turtle literal?
# This is not a precise check.
sub MatchesLiteral
{
my $term = shift;
# "foo" 'foo' """foo""" "foo"@en "foo"^^xsd:string
return 1 if $term =~ m/^[\"\']/;
# Number:
return 1 if $term =~ m/^[\+\-]?(\.?)[0-9][0-9E\-\+]*$/;
return 0;
}

################## MatchesUriTerm ##################
# Does $term seem to be a Turtle term like <uri> or p:foo?
sub MatchesUriTerm
{
my $term = shift;
return 1 if &MatchesUri($term);
return 1 if &MatchesPname($term);
return 0;
}

################## MatchesUri ##################
# Does $term seem to be a Turtle <uri> ?
sub MatchesUri
{
my $term = shift;
return 1 if $term =~ m/^\<[\~\!\#\$\%\&\(\)\*\+\,\-\.\/0-9\:\;\=\?\@A-Z_a-z]*\>$/i;
return 0;
}

################## MatchesPname ##################
# Does $term seem to be a pname like p:foo p.1: :foo : ?
sub MatchesPname
{
my $term = shift;
return 1 if $term =~ m/^([a-z]([a-z0-9_\-\.]*[a-z0-9_\-])?)?\:/i;
return 0;
}

################## Iterate #################
# Iterates through the meta cells if $fPerMetaCell is set,
# and through data cells if $fPerDataCell is set.
# $MROW must already be set. 
sub Iterate
{
my ($fPerMetaCell, $fPerDataCell) = @_;
# &SetMetaGlobalsForMRow();
if ($fPerMetaCell) {
	for ($COLUMN=0; $COLUMN<$NCOLUMNS; $COLUMN++) {
		&SetMetaGlobalsForColumn();
		&{$fPerMetaCell}();
		}
	}
if ($fPerDataCell) {
	for ($ROW=0; $ROW<$NROWS; $ROW++) {
		&SetDataGlobalsForRow();
		for ($COLUMN=0; $COLUMN<$NCOLUMNS; $COLUMN++) {
			&SetMetaGlobalsForColumn();
			&SetDataGlobalsForColumn();
			warn "  Iterate before fPerDataCell, UNDERSCORE: $_\n" if $debug > 1;
			&{$fPerDataCell}();
			warn "  Iterate after  fPerDataCell, UNDERSCORE: $_\n" if $debug > 1;
			&ResetDataGlobalsForColumn();
			}
		}
	}
}

################## Perl_PreRun #################
# Process all data rows for the current meta row $MROW.
# Called as:
#   $MROW = ...
#   &Perl_PreRun()
sub Perl_PreRun
{
my $oldDebug = $debug;
# $debug = 2;
warn "Perl_PreRun starting:  ARGS: $ARGS MROW: $MROW\n" if $debug > 1;
# Nothing to be done per meta cell:
my $fPerMetaCell = undef;
my $fPerDataCell = sub {
	# Run $ARGS on every cell
	my $saveUnderscore = $_;	# Do not overwrite $_
	if ($ARGS ne "") {
		warn "Perl_PreRun ARGS: {$ARGS} ROW: $ROW COLUMN: $COLUMN\n" if $debug > 1;
		&EvalWarnings($ARGS);
		}
	$_ = $saveUnderscore;		# Restore $_
	if ($META ne "") {
		warn "Perl_PreRun META: {$META} ROW: $ROW COLUMN: $COLUMN\n" if $debug > 1;
		&EvalWarnings($META);
		}
	$_ = $saveUnderscore;		# Restore $_
	};
&Iterate($fPerMetaCell, $fPerDataCell);
$debug = $oldDebug;
}

################## RefOf #################
# Return a ref to the given variable, whose name is given as a string.
sub RefOf
{
my $var = shift || confess "Died ";
my $ref = $REFS{$var};
if (!defined($ref)) {
	$ref = $REFS{$var} = eval("our $var = (); \\$var") if $var =~ m/^[\%\@]/;
	$ref = $REFS{$var} = eval("our $var = ''; \\$var") if $var =~ m/^\$/;
	}
return($ref);
}

################## SetMagic #################
# Save expression in @MAGICS, for evaluation later.
# 	#SetMagic $x in %h
# 	#SetMagic $x in @a
# 	#SetMagic $x in %h = expr
# 	#SetMagic $x in @a = expr
sub SetMagic
{
my $oldDebug = $debug;
# $debug = 2;
die "$0: [ERROR] SetMagic: No variable specified in metadata row $MROW\n" if $ARGS eq "";
### Parse $x in %h
my $args = $ARGS;
($args =~ s/^([\$]\w+)\s*//) || die "$0: [ERROR] SetMagic: Bad variable syntax in metadata row $MROW: $ARGS\n";
my $svar = $1;
($args =~ s/^in\s+([\%\@]\w+)\s*//) || die "$0: [ERROR] SetMagic: Bad 'in' syntax in metadata row $MROW: $ARGS\n";
my $var = $1;	# Hash or array
warn "SetMagic: Declaring scalar $svar hash/array: $var at row $ROW column $COLUMN meta row $MROW column $COLUMN: $ARGS\n" if $debug > 1;
# This check of redeclaration does not work:
# die "$0: [ERROR] SetMagic: Variable $svar redeclared at meta row $MROW column $COLUMN: $ARGS\n" if exists($VAR{$svar});
$VAR{$svar} = 1;
# die "$0: [ERROR] SetMagic: Variable $var redeclared at meta row $MROW column $COLUMN: $ARGS\n" if exists($VAR{$var});
$VAR{$var} = 1;
### Parse '= expr' if there is one
if ($args =~ s/^\=\s*(\S.*)$//) {
	# $ARGS: var = expr
	# Treat it as though expr were in every META cell.
	my $expr = $1;
	warn "SetMagic var: $var expr: $expr ARGS: $ARGS\n" if $debug > 1;
	$META eq "" || die "$0: [ERROR] SetMagic: Non-empty META when expr { $ARGS } was provided in ARGS in colum $COLUMN metadata row $MROW: $META\n";
	$META = $METAS[$COLUMN] = $expr;
	}
if ($args ne "") { die "$0: [ERROR] SetMagic: Bad expr syntax in metadata row $MROW: $ARGS\n"; }
# Eval $META
my $val = &MagicEvalWarnings($META);
die "$0: [ERROR] SetMagic: Eval returned undefined in metadata row $MROW expr: $META\n" if !defined($val);
my $vr =&RefOf($var);
$vr->[$COLUMN] = $val if $var =~ m/^\@/;
$vr->{$HEADER} = $val if $var =~ m/^\%/;
# Save for assigning later:
$MAGIC{$svar} = $var;
warn "SetMagic svar: $svar var: $var ARGS: $ARGS value: $val\n" if $val ne "" && $debug > 1;
if (0 && $debug > 1) {
	use Data::Dumper;
	warn "MAGIC VAR $var = \n";
	my $ref = eval "our $var; \\$var";
	my $d = &Dumper($ref);
	warn "$d\n";
	}
$debug = $oldDebug;
# die "STOPPED!\n";
}

################## SplitGroup #################
# A set of columns forms a tuple.  Each column has n values to
# be split.  The i'th value from each column in the tuple is
# used to add a new PENDING row.
sub SplitGroup
{
my $oldDebug = $debug;
# $debug = 2;
die "$0: [ERROR] SplitGroup does not allow an ARGS expression in meta row $MROW column $COLUMN: $ARGS\n" if $ARGS ne "";
our @vrs;
our @indexes;
our $maxValues;
our $lastIndex;
my $result = $_;
if ($META ne "") {
	if (!@vrs) {
		# First META column used.  Initialize.
		@indexes = ();
		$maxValues = 0;
		# Find the last META column used
		$lastIndex = $COLUMN;
		for (my $i=$COLUMN+1; $i<$NCOLUMNS; $i++) {
			$lastIndex = $i if $METAS[$i] ne "";
			}
		}
	my @results = map {&CellFilter($_)} &MagicEvalWarnings($META);
	$result = "";
	$result = shift(@results) if @results;
	my $nr = scalar(@results);
	$maxValues = $nr if $nr > $maxValues;
	push(@vrs, [ @results ] );
	push(@indexes, $COLUMN);
	$TABLE->[$ROW]->[$COLUMN] = $result;
	# If this was the last participating column, emit pending rows.
	if ($COLUMN == $lastIndex) {
		# Emit the pending rows
		my $warned;
		for (my $i=0; $i<$maxValues; $i++) {
			my $rr = [ @{$TABLE->[$ROW]} ];
			for (my $j=0; $j<@vrs; $j++) {
				my $v = $vrs[$j]->[$i];
				warn "$0: [WARNING] SplitGroup: Undefined value in row $ROW column $indexes[$j] from evaluating META expression: {$METAS[$indexes[$j]]}\n(Possibly a mismatched number of items?)\n"
					if !defined($v) && !$warned++;
				$v = "" if !defined($v);
				$rr->[$indexes[$j]] = $v;
				}
			unshift(@PENDING, $rr);
			}
		# Reset for the next time
		@vrs = ();
		}
	}
$_ = $result;
defined($_) || die "$0: [ERROR] SplitGroup Eval of META failed: $?\n";
# warn "  After eval(ARGS . META) UNDERBAR: $_\n" if $META ne "" && $debug > 1;
$debug = $oldDebug;
}

################## Perl_Filter #################
# If an expression yields more than one value then the additional
# values are placed into PENDING rows, to be processed before the
# next regular row iteration.
sub Perl_Filter
{
my $oldDebug = $debug;
# $debug = 2;
my $expr = $ARGS;
$expr .= "\n; " if $ARGS ne "" && $META ne "";
$expr .= $META;
warn "Called Perl_Filter(@_) UNDERBAR: $_ META: $META ARGS: $ARGS expr: $expr\n" if $expr ne "" && $debug > 1;
# Empty filter means pass the data through unchanged.
if ($expr ne "") {
	my @results = &MagicEvalWarnings($expr);
	my $n = scalar(@results);
	warn "Perl_Filter evaluated to $n PENDING raw values: (@results)\n" if $expr ne "" && $debug > 1;
	@results = map {defined($_) ? &CellFilter($_) : $_} @results;
	@results = grep {!defined($_) || $_ ne ""} @results;
	my $underbar = "";
	$underbar = shift @results if @results;
	if (@results) {
		my @newRows = map { my $rr = [ @{$TABLE->[$ROW]} ];
					$rr->[$COLUMN] = $_;
					$rr } @results;
		unshift(@PENDING, @newRows);
		if (0 && $HEADER =~ m/technology/) {
			warn "New rows:\n";
			foreach my $r (@newRows) {
				warn "  $r->[$COLUMN] $r->[$COLUMN+1]\n";
				}
			}
		warn "Perl_Filter added $n PENDING rows for: (@results)\n" if $debug > 1;
		}
	$_ = $underbar;
	}
defined($_) || die "$0: [ERROR] Eval of META . ARGS {$expr} failed: $?\n";
warn "  After eval(ARGS . META) UNDERBAR: $_\n" if $expr ne "" && $debug > 1;
$debug = $oldDebug;
}

################## Echo #################
# Print a triple for each non-empty cell in the table, using the current 
# subject $S, the current property $P and the expression given in $META .
# The resulting value will be quoted as a string.
sub Echo
{
warn "Called Echo(@_)\n" if $debug > 1;
return if !$S || !$P || !defined($META) || $META eq "";
return if !defined($_) || $_ eq "";
my $v = &MagicEvalWarnings($META);
defined($v) || die "$0: [ERROR] Echo: Eval of META {$META} failed: $?\n";
# Always quote as strings:
$v = &Quote($v);
print "$S $P $v .\n";
return;
}

################## End #################
# Eval the expressions after everything else is done.
sub End
{
@_ == 0 || confess "Died";
my $oldDebug = $debug;
# $debug = 2;
warn "#End starting:  ARGS: $ARGS MROW: $MROW\n" if $debug > 1;
# Nothing to be done per data cell:
my $fPerDataCell = undef;
my $fPerMetaCell = sub {
	&MagicEvalWarnings($META) if $META ne "";
	};
&Iterate($fPerMetaCell, $fPerDataCell);
$debug = $oldDebug;
}

################## Prefix #################
# Prefix is a preprocessing directive.
sub Prefix
{
die "$0: [ERROR] Unknown ARGS in Prefix directive on metadata row $MROW: $ARGS\n" if $ARGS;
my $oldDebug = $debug;
# $debug = 2;
for ($COLUMN=0; $COLUMN<@METAS; $COLUMN++) {
	&SetMetaGlobalsForColumn();
	next if $META !~ m/\S/;
	my $originalMeta = $META;
	# Ignore optional "@prefix" and trailing period:
	$META =~ s/^\@//;
	$META =~ s/^prefix\s+//i;
	$META =~ s/\s*\.$//;
	my ($prefix, $uri) = ($META =~ m/^([^\:]*\:)\s*(.+)$/);
	die "$0: [ERROR] Bad prefix declaration in column $COLUMN {$HEADER} row $ROW: $originalMeta\n"
		if !defined($uri);
	# warn "PREFIX: $prefix URI: $uri META: $META\n";
	# Perl convenience: Auto-quote if the expression contains $
	$uri = '"' . $uri . '"' if $uri =~ m/\$/;
	# warn "After auto quote PREFIX: $prefix URI: $uri META: $META\n";
	# Eval as a perl expression if it starts with quote:
	$uri = &EvalWarnings($uri) if $uri =~ m/^[\'\"]/;
	# warn "After eval PREFIX: $prefix URI: $uri META: $META\n";
	die "$0: [ERROR] Prefix declaration failed in column $COLUMN {$HEADER} row $ROW: $originalMeta\n"
		if !defined($uri) || $uri eq "";
	# Auto-wrap in <..> if needed:
	$uri = "<$uri>" if $uri !~ m/^\</;
	&MatchesUri($uri) || warn "$0: [WARNING] Unusual prefix URI '$uri' in column $COLUMN {$HEADER} row $ROW from declaration: $originalMeta\n";
	$NAMESPACE{$prefix} = $uri;
	warn "  PREFIX: $prefix $uri\n" if $debug;
	}
$debug = $oldDebug;
# die "STOPPED!\n";
}

################## SetVar #################
# Set %VAR, for use in URI Templates.
# Preprocessing directive.
sub SetVar
{
my $oldDebug = $debug;
# $debug = 2;
die "$0: [ERROR] SetVar: No variable specified in metadata row $MROW\n" if $ARGS eq "";
my $args = $ARGS;
($args =~ s/^([\$\%\@]\w+)\s*//) || die "$0: [ERROR] SetVar: Bad variable syntax in metadata row $MROW: $ARGS\n";
my $var = $1;
die "$0: [ERROR] SetVar: Variable $var redeclared at meta row $MROW column $COLUMN: $META\n" if exists($VAR{$var});
$VAR{$var} = 1;
my $ref = eval "our $var; \\$var";
if ($args ne "") {
	# $ARGS: var = expr
	($args =~ m/^\=\s*(\S.*)$/) || die "$0: [ERROR] SetVar: Bad expression syntax in metadata row $MROW: $ARGS\n";
	my $expr = $1;
	warn "SetVar var: $var expr: $expr ARGS: $ARGS\n" if $debug > 1;
	my $val;
	if ($var =~ m/^\$/) { $val = &EvalWarnings($ARGS); }
	else 	{
		my @val = &EvalWarnings($ARGS);
		$val = join(" ", @val);
		}
		
	$val = "(UNDEF)" if !defined($val);
	warn "SetVar var: $var set to: $val\n" if $debug;
	}
else	{
	# Evaluate all @METAS to assign to $var
	my @values = ();
	${$ref} = "" if $var =~ m/^\$/;;
	for ($COLUMN=0; $COLUMN<@METAS; $COLUMN++) {
		my $val = "";
		if ($METAS[$COLUMN] =~ m/\S/) {
			&SetMetaGlobalsForColumn();
			$val = &EvalWarnings($META);
			die "$0: [ERROR] SetVar: Expression eval failed in metadata row $MROW: $META\n" if !defined($val);
			warn "SetVar evaluated META: $META = $val\n" if $debug;
			}
		${$ref}{$HEADERS[$COLUMN]} = $val if $var =~ m/^\%/;
		${$ref}[$COLUMN] = $val if $var =~ m/^\@/;
		${$ref} .= $val if $var =~ m/^\$/;;
		}
	}
if (0 && $debug > 1) {
	use Data::Dumper;
	warn "VAR $var = \n";
	my $d = &Dumper($ref);
	warn "$d\n";
	}
$debug = $oldDebug;
# die "STOPPED!\n";
}

################## Perl_RunArg #################
sub Perl_RunArg
{
my $oldDebug = $debug;
# $debug = 2;
my $saveUnderbar = $_;
my $shouldWarn = $debug && ($ARGS || $META);
warn "Called Perl_RunArg(@_) UNDERBAR: $_ META: $META ARGS: $ARGS\n" if $shouldWarn;
# my $once = ($ARGS =~ s/^once\b\s*//);
# "Run once" runs on every data cell (even if empty), whereas
# regular "Run" only runs on non-empty cells.
# if (($once && $ROW == 0) || (!$once && $_ ne "")) {
my $result = "";
$result = &MagicEvalWarnings($ARGS) if $ARGS ne "";
warn "  Perl_RunArg After eval(ARGS) UNDERBAR: $_\n" if $shouldWarn;
$_ = $saveUnderbar;
warn "  Perl_RunArg Done Perl_RunArg(@_) UNDERBAR: $_ ARGS: $ARGS\n" if $shouldWarn;
$debug = $oldDebug;
}

################## Perl_Run #################
# Run both ARGS and META
sub Perl_Run
{
my $oldDebug = $debug;
# $debug = 2 if $META =~ m/properties/;
my $saveUnderbar = $_;
my $shouldWarn = $debug && ($ARGS || $META);
warn "Called Perl_Run(@_) UNDERBAR: $_ META: $META ARGS: $ARGS\n" if $shouldWarn;
my $expr = $ARGS;
$expr .= "\n; " if $ARGS ne "" && $META ne "";
$expr .= $META;
warn "  Perl_Run before eval(ARGS . META) UNDERBAR: $_\n" if $shouldWarn;
my $result = &MagicEvalWarnings($expr) if $expr ne "";
warn "  Perl_Run After eval(ARGS . META) UNDERBAR: $_\n" if $shouldWarn;
$_ = $saveUnderbar;
warn "  Perl_Run Done Perl_Run(@_) UNDERBAR: $_ ARGS: $ARGS\n" if $shouldWarn;
$debug = $oldDebug;
}

################# MagicEvalWarnings ##################
# Set MAGIC vars and then run EvalWarnings.
# This should only be called if $ROW $COLUMN and $HEADER are set, i.e.,
# when processing data cells.
sub MagicEvalWarnings
{
@_ == 1 || confess "Died";
my $expr = shift @_;
defined($expr) || confess "Died";
return "" if $expr eq "" || $expr eq '""' || $expr eq "''";
# Set magic vars
foreach my $svar (keys %MAGIC) {
	my $sr = &RefOf($svar);
	my $hvar = $MAGIC{$svar};
	my $hr = &RefOf($hvar);
	${$sr} = $hr->{$HEADER} if $hvar =~ m/^\%/;
	${$sr} = $hr->[$COLUMN] if $hvar =~ m/^\@/;
	}
return &EvalWarnings($expr);
}

################# EvalWarnings ##################
# Run eval while trapping warnings, and return the eval result.
# Warnings and errors are reported.  Old eval errors are cleared first.
# %VAR variables are declared as "our".
# Usage:
#   my $result = &EvalWarnings($expr);
sub EvalWarnings
{
@_ == 1 || confess "Died";
my $expr = shift @_;
defined($expr) || confess "Died";
return "" if $expr eq "" || $expr eq '""' || $expr eq "''";
# warn "EVAL: $expr\n";
my $ours = join("", map {"our $_; "} sort keys %VAR);
my $de = "$ours \{\n$expr\n\}";
return &RawEvalWarnings($de);
}

################# RawEvalWarnings ##################
# Run eval while trapping warnings, and return the eval result.
# Warnings and errors are reported.  Old eval errors are cleared first.
# Usage:
#   my $result = &RawEvalWarnings($expr);
sub RawEvalWarnings
{
@_ == 1 || confess "Died";
my $expr = shift @_;
defined($expr) || confess "Died";
return "" if $expr eq "";
my $underscore = $_;
$underscore = "(undef)" if !defined($underscore);
warn "      RawEvalWarnings starting expr: {$expr} UNDERSCORE: $underscore\n" if $debug > 2;
my $result = "";
my @result = ();
my $warning = "";
# Clear old errors prior to eval.  $@ does not need to be cleared,
# because it is reset by perl.
$! = 0;
$? = 0;
my $wantarray = wantarray;
#### Create a new scope for trapping warnings.
#### DO NOT TRY TO CALL warn FROM THIS SCOPE!
	{
	local $SIG{__WARN__} = sub {
		$warning .= (shift || "");
		};
	if ($wantarray) { @result = eval $expr; }
	else { $result = eval $expr; }
	}
my $error = $@ || "";
$underscore = $_;
if ($wantarray) {
	$result = join(" ", map { defined($_) ? $_ : "(undef)" } @result);
	}
$underscore = "(undef)" if !defined($underscore);
warn "wantarray\n" if $wantarray && $debug > 1;
warn "expr: $expr\n" if $debug > 1;
warn "      RawEvalWarnings after eval, expr: {$expr} UNDERSCORE: $underscore result: $result\n" if $debug > 2;
if ($warning || $error) {
	$result = join(" ", map { defined($_) ? $_ : "(undef)" } @result) if $wantarray;
	my $directive = $DIRECTIVE || "INTERNAL";
	my $args = $ARGS || "(undef)";
	my $mrow = (defined($MROW) ? $MROW : "(undef)");
	my $column = (defined($COLUMN) && $COLUMN < $NCOLUMNS && $COLUMN >= 0 ? $COLUMN : undef);
	my $header = (defined($column) ? $HEADERS[$column] : undef);
	my $cell = (defined($column) && defined($ROW) 
		? $TABLE->[$ROW]->[$column] : undef);
	my $max = 400;
	my $shortExpr = (defined($expr) ? $expr : "");
	$shortExpr = substr($shortExpr, 0, $max-3) . "..." if length($shortExpr) > $max;
	my $shortCell = (defined($cell) ? $cell : "");
	$shortCell = substr($shortCell, 0, $max-3) . "..." if length($shortCell) > $max;
	my $shortMeta = (defined($META) ? $META : "");
	$shortMeta = substr($shortMeta, 0, $max-3) . "..." if length($shortMeta) > $max;
	my $WE = ($warning ? "WARNING" : "ERROR");
	my $we = ($warning ? "a warning" : "an error");
	my $weText = ($warning ? $warning : $error);
	my $msg = "$0: [$WE] $directive: eval of {$shortExpr} at meta row $mrow";
	$msg .= " column $column {$header}" if defined($column);
	$msg .= " meta cell {$shortMeta}" if defined($META);
	$msg .= " data row $ROW" if defined($ROW);
	$msg .= " data cell {$shortCell}" if defined($cell);
	$msg .= " produced $we: $weText\n";
	# warn "header: $header\n";
	# warn "column: $column\n";
	# warn "NCOLUMNS: $NCOLUMNS\n";
	# warn "HEADERS[$column]: $HEADERS[$column]\n";
	if ($warning) { warn $msg; }
	else { die $msg; }
	}
return @result if $wantarray;
return $result;
}

################# RemoveMetadataRows ##################
# Destructively remove and return metadata rows from the given data table.
# Metadata rows are returned as a ref to an array of row refs -- the
# same form as the given data table.  The metadata directive is
# the first cell in each metadata row.  The #META column is removed
# entirely from the data table.  
sub RemoveMetadataRows
{
my $tsv = shift @_ || confess "Died";
my $meta = [];
my $firstCellValue = $tsv->[0]->[0];
defined($firstCellValue) || die "$0: [ERROR] Table has no header row!\n";
# warn "firstCellValue: {$firstCellValue}\n";
return $meta if $firstCellValue ne "#META";
# Strip "#META" from header column:
shift(@{$tsv->[0]});
# Remove and collect the metadata rows:
for (my $r=1; $r < @{$tsv}; $r++) {
	my $row = $tsv->[$r];
	# Strip the #META column from all rows:
	my $metaCell = shift(@{$row});
	# Non-empty meta column means it's a meta row -- not a data row.
	next if ($metaCell !~ m/\S/);
	# warn "META row $r.  metaCell: $metaCell\n";
	# Meta row.  Delete it from data table.
	splice(@{$tsv}, $r, 1);
	$r--;
	# Empty or comment meta cell?
	next if $metaCell =~ m/^\#\s*(\#.*)?$/;
	if ($metaCell !~ s/^\#(\S*)\s*//) {
		die "$0: [ERROR] Unrecognized meta directive in row $r: $metaCell\n";
		}
	my $directive = $1;
	my $args = $metaCell;
	# warn "META pushing: $directive $args @{$row}\n";
	push(@{$meta}, [ $directive, $args, @{$row} ]);
	}
return $meta;
}

############### PrintTable ###############
sub PrintTable
{
my $tsv = shift @_ || confess "Died";
foreach my $row (@{$tsv}) {
	my $line = join("\t", @{$row});
	print "$line\n";
	}
}

################# ReadTable #####################
sub ReadTable
{
@_ == 3 || confess "Died";
my ($infile, $worksheet, $format) = @_;
my $rTable = &ReadRawTable($infile, $worksheet, $format);
return $rTable if !$rTable or !@{$rTable};
# Always trim the header row.
@{$rTable->[0]} = map {&Trim($_)} @{$rTable->[0]};
# Remove empty trailing columns?
my $continueRemoving = !$keepEmptyTrailingColumns;
my $nRemoved = 0;
while($continueRemoving) {
	warn "Checking for empty trailing column in '$infile' ...\n" if $debug > 1;
	my $c = scalar(@{$rTable->[0]}) - 1;	# Last column
	last if $c < 0;
	my $allEmpty = 1;
	for (my $r=0; $r<@{$rTable}; $r++) {
		if ($rTable->[$r]->[$c] =~ m/\S/) {
			$allEmpty = 0;
			last;
			}
		}
	if ($allEmpty) {
		warn "Removing empty trailing column from '$infile'\n" if $debug > 1;
		for (my $r=0; $r<@{$rTable}; $r++) {
			pop @{$rTable->[$r]};
			}
		$nRemoved++;
		}
	else { $continueRemoving = 0; }
	}
warn "Removed $nRemoved trailing empty columns from '$infile'\n" if $debug && $nRemoved;
# Remove empty trailing rows?
$continueRemoving = !$keepEmptyTrailingRows;
my $saveDebug = $debug;
# $debug = 3;
$nRemoved = 0;
while($continueRemoving) {
	warn "Checking for empty trailing row in '$infile' ...\n" if $debug > 2;
	# my $c = scalar(@{$rTable->[0]}) - 1;
	my $r = scalar(@{$rTable}) - 1;		# Last row
	last if $r < 0;
	my $allEmpty = 1;
	# for (my $r=0; $r<@{$rTable}; $r++) {
	for (my $c=0; $c<@{$rTable->[$r]}; $c++) {
		if ($rTable->[$r]->[$c] =~ m/\S/) {
			$allEmpty = 0;
			last;
			}
		}
	if ($allEmpty) {
		warn "Removing empty trailing row $r from '$infile'\n" if $debug > 2;
		pop @{$rTable};
		$nRemoved++;
		}
	else { $continueRemoving = 0; }
	}
warn "Removed $nRemoved trailing empty rows from '$infile'\n" if $debug && $nRemoved;
$debug = $saveDebug;
return $rTable;
}

################# ReadRawTable #####################
# Determine the file type from the file extension or $format,
# and invoke the appropriate %readerForFormat to read the
# specified worksheet from the specified file.  Returns
# a ref to an array (the rows) of array refs (the cells).
# The first row will be the header row.   Usage:
#   my $table = &ReadRawTable("foo.xlsx", "Worksheet1", $format);
# Uses global %readerForFormat.
sub ReadRawTable
{
@_ == 3 || confess "Died";
my ($infile, $worksheet, $format) = @_;
# Grrr.  Ridiculous that perl doesn't have a standard function to
# parse the file extension.
my ($ext) = ($infile =~ m/\.([^\.]*)$/);
$ext = "" if !defined $ext;
my $encoding = "";
$encoding = $1 if $format =~ s/\:(.*)$//;
$format = lc($format || $ext);
# die "infile: $infile format: $format ext: $ext\n";
$format || die "$0: [ERROR] Unable to determine file format from filename '$infile'.  
Please use the '-f fmt' option (for a data file) or '-F fmt' option
(for a metadata file) to specify the file type.\n";
my $reader = $readerForFormat{$format} || die "$0: [ERROR] Unimplemented spreadsheet file type: $format\n";
# Disable reference warnings:
no strict 'refs';
# &CellFilter is passed in explicitly to help ensure that new readers
# do not forget to call it.
my $rTable = &{$reader}($infile, $worksheet, \&CellFilter); 
$rTable || die "$0: [ERROR] Failed to read data file '$infile' worksheet '$worksheet' as $format\n";
return $rTable;
}

########## ReadTsv ###########
# Read a TSV file from a filename (if given) or stdin,
# trimming leading and trailing whitespace from all cells.
# Returns a reference to an array (the rows) of array 
# references (the column values).  The result is guaranteed
# to have the same number of cells in each row.
sub ReadTsv
{
@_ == 3 or confess "Died";
my ($f, $worksheet, $cellFilter) = @_;
$f ||= "";
defined($worksheet) || confess "Died";
$f = "" if $f eq "-";
my $fh = \*STDIN;
!$f || open($fh, "<$f") || die "$0: [ERROR] Cannot open $f\n";
my $result = [];
my $nColumns = 0;
my $row = 0;
while (my $line = <$fh>) {
	chomp $line;
	no strict 'refs';
	my @fields = map {&{$cellFilter}($_)} split(/\t/, $line, -1);
	@fields || die "$0: [ERROR] No data fields found in " . ($f ? "STDIN" : $f) . "\n";
	my $nf = scalar(@fields);
	$nColumns = $nf if !$nColumns;
	$nf == $nColumns || die "$0: [ERROR] Number of data columns ($nf) does not match the number of header columns ($nColumns) on data row $row in " . ($f ? "STDIN" : $f) . "\n";
	# warn "\tRead $nf columns\n";
	push(@{$result}, [ @fields ] );
	$row++;
	}
!$f || close($fh);
# warn "Read $row rows\n";
return $result;
}

########## ReadXlsx ###########
# Read a .xlsx file from a filename (if given) or stdin,
# trimming leading and trailing whitespace from all cells.
# Optionally the worksheet may be specified:
#       my $table = &ReadXlsx("myFile.xlsx", "Worksheet1");
# Otherwise, the first is used.
# Returns a reference to an array (the rows) of array 
# references (the column values).  The result is guaranteed
# to have the same number of cells in each row.
sub ReadXlsx
{
@_ == 3 or confess "Died";
my ($f, $worksheet, $cellFilter) = @_;
$f ||= "";
defined($worksheet) || confess "Died";
$worksheet ||= 0;	# Change "" to 0 if necessary.
$f = "" if $f eq "-";
my $fh = \*STDIN;
!$f || open($fh, "<$f") || die "$0: [ERROR] Cannot open $f\n";
my $result = [];
my $nColumns = 0;
my $row = 0;
use Spreadsheet::ParseXLSX;
# Profiling seems to be too slow in the parser:
DB::disable_profile() if $fasterProfiling;
my $excel = Spreadsheet::ParseXLSX->new()->parse($fh);
DB::enable_profile() if $fasterProfiling;
my @worksheets = $excel->worksheets();
# my $nWorksheets = scalar(@worksheets);
my $nWorksheets = $excel->worksheet_count();
warn "nWorksheets: $nWorksheets File: $f\n" if $debug > 0;
my $worksheetObject = $excel->worksheet($worksheet);
$worksheetObject || return undef;
my $table = [];
my ( $row_min, $row_max ) = $worksheetObject->row_range();
warn "Row range: $row_min : $row_max\n" if $debug > 0;
my ( $col_min, $col_max ) = $worksheetObject->col_range();
warn "Col range: $col_min : $col_max\n" if $debug > 0;
my $r=0;
for my $row ( $row_min .. $row_max ) {
	my $nextRow = [];
	my $c=0;
	for my $col ( $col_min .. $col_max ) {
		my $v = "";	# Default to empty string
		my $cell = $worksheetObject->get_cell( $row, $col );
		if ($cell) {
			$v = $cell->value();
			# warn "Row, Col    = ($row, $col)\n" if $debug > 1;
			# warn "Value       = ", $cell->value(),       "\n" if $debug > 1;
			# warn "Unformatted = ", $cell->unformatted(), "\n" if $debug > 1;
			# warn "\n" if $debug > 1;
			}
		no strict 'refs';
		push(@{$nextRow}, &{$cellFilter}($v));
		$c++;
		}
	$table->[$r] = $nextRow;
	$r++;
	}
my $nc = $col_max - $col_min + 1;
$nc = 0 if $nc < 0;
warn "Read $r rows $nc columns from $f\n" if $debug;
return $table;
}

########## Split ############
# Split a string at separators, returning only non-empty results
# after Trimming whitespace.
sub Split
{
@_ == 2 || confess "Died";
my ($separator, $s) = @_;
my $qs = quotemeta($separator);
my @raw = split(/$qs/, $s);
my @cooked = grep {$_ ne ""} map {&Trim($_)} @raw;
return @cooked;
}

########## Trim ############
# Perl function to remove whitespace from beginning and end of a string.
sub Trim
{
my $s = shift @_;
$s =~ s/\A[\s\n\r]+//s;
$s =~ s/[\s\n\r]+\Z//s;
return $s;
}

########## DeleteControlChars ###########
sub DeleteControlChars
{
my $v = shift @_;
defined($v) || confess "Died";
$v =~ tr/\000-\037/ /;
return $v;
}

########## Clean ###########
# Trim leading and trailing whitespace, turn everything but [a-zA-Z0-9_]
# into underscore ("_") and change any occurrences of multiple
# underscores into a single underscore (in order to treat multiple
# blanks as a single blank).
sub Clean
{
my $v = shift @_;
defined($v) || confess "Died";
$v = &Trim($v);
$v =~ s/[^A-Za-z0-9_]/_/g;
$v =~ s/_+/_/g;
return $v;
}

########## Quote ############
# Escape the given string as necessary, and wrap it in
# """triple quotes""" for output as an RDF literal.
sub Quote
{
my $s = shift @_;
return '"""' . &TripleQuoteSafe($s) . '"""';
}

########## TripleQuoteSafe ############
# Make a string safe to write as a Turtle """string""".  
# Backslashes and quotes " are escaped.  Nothing else is.
# http://www.w3.org/TR/turtle/#string
sub TripleQuoteSafe
{
my $s = shift @_;
$s =~ s/([\"\\])/\\$1/gms;			# \   --> \\
return $s;
}

########## QuoteSafe ############
# Make a string safe to write as a single-line Turtle "string".  Prohibited
# characters [\"\r\n\\] are silently changed to spaces.
# http://www.w3.org/TR/turtle/#string
sub QuoteSafe
{
my $s = shift @_;
$s =~ s/[\"\r\n\\]/ /gms;
return $s;
}

########## MakeVar ###########
# Turn the given column name into a variable,
# or return the empty string if failure.
sub MakeVar
{
my $v = shift @_;
$v = &Clean($v);
# $v =~ s/_$//;
# $v =~ s/^_//;
$v = "" if $v !~ m/^[A-Za-z]/;	# Must start with a letter
return $v;
}

################# MimeTypeOfFile #####################
# UNUSED CODE.  This was for testing the possibility of
# determining a file's MIME type from its name or contents,
# but it did not work well.  A simple foo.csv file showed
# as having different MIME types based on the filename (correct: text/csv)
# versus the content (wrong: application/octet-stream).
# Thus, that technique was abandoned.  But I am keeping the
# code here in case someone wants to pursue it again some day.
sub MimeTypeOfFile
{
my $f = shift || die;
use MIME::Types;
use File::Type;
my $ft = File::Type->new();
my $types = MIME::Types->new( only_complete => 1 );
my $mime = $types->mimeTypeOf($f);
$mime = "UNDEFINED" if !defined $mime;
print "mime from filename: $mime\n";
# alternatively, check file from disk
$mime = $ft->checktype_filename($f);
$mime = "UNDEFINED" if !defined $mime;
print "mime from contents: $mime\n";
return $mime;
}

